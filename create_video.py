#!/usr/bin/env python3
"""
Script to create video from BMP frames generated by cross-fading programs.
Requires OpenCV (cv2) and numpy libraries.
Install with: pip install opencv-python numpy
"""

import cv2
import os
import sys
import glob
import argparse

def create_video_from_frames(frame_prefix, output_video, fps=24):
    """
    Create a video file from BMP frames.

    Args:
        frame_prefix (str): Prefix of frame files (e.g., "frame" for frame_0.bmp, frame_1.bmp, etc.)
        output_video (str): Output video filename
        fps (int): Frames per second for the video
    """

    # Find all frame files - try different patterns
    patterns = [
        f"{frame_prefix}_*.png",
        f"{frame_prefix}_*.bmp",
        f"{frame_prefix}*.png",
        f"{frame_prefix}*.bmp"
    ]

    frame_files = []
    import re
    for pattern in patterns:
        # Use a regex to extract numbers and sort numerically
        try:
            frame_files = sorted(
                glob.glob(pattern),
                key=lambda f: int(re.search(r'_(\d+)\.(png|bmp)$', f).group(1))
            )
        except (AttributeError, ValueError):
            # Fallback for filenames that don't match the pattern
            frame_files = sorted(glob.glob(pattern))

        if frame_files:
            print(f"Found {len(frame_files)} frames with pattern: {pattern}")
            break

    if not frame_files:
        print(f"No frame files found with any of these patterns: {patterns}")
        return False

    # Frame ordering is now guaranteed by the sort above
    print(f"Frame ordering verified: {len(frame_files)} frames from 0 to {len(frame_files)-1}")

    # Read first frame to get dimensions
    first_frame = cv2.imread(frame_files[0])
    if first_frame is None:
        print(f"Error reading first frame: {frame_files[0]}")
        return False

    height, width = first_frame.shape[:2]
    print(f"Frame dimensions: {width}x{height}")

    # Create video writer
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # MP4 codec
    video_writer = cv2.VideoWriter(output_video, fourcc, fps, (width, height))

    if not video_writer.isOpened():
        print("Error: Could not create video writer")
        return False

    print(f"Creating video: {output_video}")

    # Add frames to video in numerical order
    print("Processing frames in order:")
    for i, frame_file in enumerate(frame_files):
        frame = cv2.imread(frame_file)
        if frame is None:
            print(f"Warning: Could not read frame {frame_file}")
            continue

        video_writer.write(frame)

        # Show first few and last few frame filenames for verification
        if i < 3 or i >= len(frame_files) - 3:
            print(f"  Frame {i}: {os.path.basename(frame_file)}")

        if (i + 1) % 10 == 0:
            print(f"Processed {i + 1}/{len(frame_files)} frames")

    # Ensure all frames are written by checking frame count
    expected_frames = len(frame_files)
    print(f"Expected {expected_frames} frames, processed {len(frame_files)} frames")

    video_writer.release()
    print(f"Video created successfully: {output_video}")
    return True

def main():
    parser = argparse.ArgumentParser(description='Create video from image frames')
    parser.add_argument('frame_prefix', help='Prefix of frame files (e.g., "frame_sequential", "frame_mpi", "frame_openmp_4")')
    parser.add_argument('output_video', help='Output video filename (e.g., "output.mp4")')
    parser.add_argument('--fps', type=int, default=24, help='Frames per second (default: 24)')

    args = parser.parse_args()

    print(f"Looking for frames with prefix: {args.frame_prefix}")
    if not create_video_from_frames(args.frame_prefix, args.output_video, args.fps):
        sys.exit(1)

if __name__ == "__main__":
    main()